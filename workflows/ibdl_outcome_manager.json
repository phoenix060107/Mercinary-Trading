{  "name": "ibdl_outcome_manager",  "nodes": [    {      "parameters": {        "triggerTimes": {          "item": [{ "mode": "everyX", "value": 1, "unit": "hours" }]        }      },      "name": "Cron Hourly",      "type": "n8n-nodes-base.cron",      "typeVersion": 1,      "position": [220, 320]    },    {      "parameters": {        "command": "set -e\nLOGDIR=\"/data/valkyrie/logs\"\nSTATE_FILE=\"$LOGDIR/ibdl_state.json\"\nEVENTS_FILE=\"$LOGDIR/mr_events.csv\"\n\nmkdir -p \"$LOGDIR\"\n\nif [ ! -f \"$STATE_FILE\" ]; then\n  echo '{\"state\":\"ACTIVE\",\"last_change_ts\":0}' > \"$STATE_FILE\"\nfi\n\nif [ ! -f \"$EVENTS_FILE\" ]; then\n  echo 'event_ts,event_type,signal_id,pair,entry_price,signal,mae_pct,mfe_pct,bars_to_ma50,hit_ma50,structure_hold,fail,state' > \"$EVENTS_FILE\"\nfi\n\necho \"OK\""      },      "name": "Preflight Files",      "type": "n8n-nodes-base.executeCommand",      "typeVersion": 1,      "position": [430, 320]    },    {      "parameters": {        "command": "tail -n 3000 /data/valkyrie/logs/mr_events.csv"      },      "name": "Read Recent Events",      "type": "n8n-nodes-base.executeCommand",      "typeVersion": 1,      "position": [650, 320]    },    {      "parameters": {        "functionCode": "const text = (items[0].json?.stdout || '').trim();\nconst lines = text.split(/\\r?\\n/);\nif (lines.length < 2) return [];\n\nconst header = lines[0].split(',');\nconst idx = Object.fromEntries(header.map((h,i)=>[h,i]));\n\nfunction rowToObj(line){\n  const parts = line.split(',');\n  return {\n    event_ts: parts[idx.event_ts],\n    event_type: parts[idx.event_type],\n    signal_id: parts[idx.signal_id],\n    pair: parts[idx.pair],\n    entry_price: parts[idx.entry_price],\n    signal: parts[idx.signal],\n    fail: parts[idx.fail]\n  };\n}\n\nconst events = lines.slice(1).filter(Boolean).map(rowToObj);\nconst haveOutcome = new Set(events.filter(e=>e.event_type==='OUTCOME').map(e=>e.signal_id));\n// Filter for SIGNALs that were true and don't have outcome\nconst pendingSignals = events\n  .filter(e=>e.event_type==='SIGNAL' && e.signal==='true' && !haveOutcome.has(e.signal_id))\n  .slice(-30);\n\nreturn pendingSignals.map(s => ({ json: s }));"      },      "name": "Select Pending Signals",      "type": "n8n-nodes-base.function",      "typeVersion": 2,      "position": [880, 320]    },    {      "parameters": { "batchSize": 1, "options": {} },      "name": "Split Pending",      "type": "n8n-nodes-base.splitInBatches",      "typeVersion": 3,      "position": [1080, 320]    },    {      "parameters": {        "url": "https://api.kraken.com/0/public/OHLC",        "options": {},        "queryParametersUi": {          "parameter": [            { "name": "pair", "value": "={{$json.pair}}" },            { "name": "interval", "value": "240" }          ]        }      },      "name": "Fetch OHLC 4H",      "type": "n8n-nodes-base.httpRequest",      "typeVersion": 4,      "position": [1280, 320]    },    {      "parameters": {        "functionCode": "function sma(arr, n) {\n  const out = new Array(arr.length).fill(null);\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (i >= n) sum -= arr[i - n];\n    if (i >= n - 1) out[i] = sum / n;\n  }\n  return out;\n}\n\nconst sig = $json;\nconst resp = items[0].json;\nconst result = resp?.result || {};\nconst keys = Object.keys(result).filter(k => k !== 'last');\nif (!keys.length) return [{ json: { ok:false, reason:'No OHLC', ...sig } }];\n\nconst rows = result[keys[0]];\nconst signalTs = parseInt(sig.event_ts, 10);\nconst entry = parseFloat(sig.entry_price);\n\nconst times = rows.map(r => parseInt(r[0], 10));\nlet startIdx = times.findIndex(t => t >= signalTs);\nif (startIdx < 0) startIdx = rows.length - 1;\n\n// Forward window 12 bars\nconst FORWARD = 12;\nconst slice = rows.slice(startIdx, Math.min(rows.length, startIdx + FORWARD));\nconst highs = slice.map(r => parseFloat(r[2]));\nconst lows = slice.map(r => parseFloat(r[3]));\nconst closes = rows.map(r => parseFloat(r[4]));\nconst ma50 = sma(closes, 50);\n\n// Use MA50 at end of window\nconst ma50_val = ma50[Math.min(rows.length-1, startIdx + FORWARD - 1)];\n\nlet mae=0, mfe=0;\nfor (let i=0; i<slice.length; i++) {\n  if (lows[i] < entry) { const d=(lows[i]-entry)/entry; if(d<mae) mae=d; }\n  if (highs[i] > entry) { const d=(highs[i]-entry)/entry; if(d>mfe) mfe=d; }\n}\n\n// Logic: Hit MA50 = Win. Drop > 3% = Fail.\nlet hit_ma50 = false;\nif (ma50_val) hit_ma50 = highs.some(h => h >= ma50_val);\nconst structure_hold = mae >= -0.03;\nconst fail = (!hit_ma50) || (!structure_hold);\n\nreturn [{\n  json: {\n    signal_id: sig.signal_id,\n    pair: sig.pair,\n    entry_price: entry,\n    mae_pct: (mae*100).toFixed(4),\n    mfe_pct: (mfe*100).toFixed(4),\n    fail: fail ? '1' : '0'\n  }\n}];"      },      "name": "Compute OUTCOME",      "type": "n8n-nodes-base.function",      "typeVersion": 2,      "position": [1480, 320]    },    {      "parameters": {        "command": "set -e\nLOG='/data/valkyrie/logs/mr_events.csv'\nEVENT_TS=$(date +%s)\nEVENT_TYPE='OUTCOME'\nSIGNAL_ID='{{$json.signal_id}}'\nPAIR='{{$json.pair}}'\nENTRY_PRICE='{{$json.entry_price}}'\nSIGNAL='true'\nFAIL='{{$json.fail}}'\nMAE='{{$json.mae_pct}}'\nMFE='{{$json.mfe_pct}}'\n\necho \"$EVENT_TS,$EVENT_TYPE,$SIGNAL_ID,$PAIR,$ENTRY_PRICE,$SIGNAL,$MAE,$MFE,,, ,$FAIL,\" >> \"$LOG\""      },      "name": "Append OUTCOME event",      "type": "n8n-nodes-base.executeCommand",      "typeVersion": 1,      "position": [1680, 320]    },    {      "parameters": {        "command": "python3 - << 'PY'\nimport csv, json, time\nfrom collections import deque\nEVENTS='/data/valkyrie/logs/mr_events.csv'\nSTATE='/data/valkyrie/logs/ibdl_state.json'\n\nw = deque(maxlen=2000)\ntry:\n  with open(EVENTS,newline='') as f:\n    r = csv.DictReader(f)\n    for row in r:\n      if row.get('event_type')=='OUTCOME' and row.get('fail') in ('0','1'):\n        w.append(row)\nexcept: pass\n\nlast20 = list(w)[-20:]\nfails = sum(1 for x in last20 if x['fail']=='1')\n\ntry: st = json.load(open(STATE))\nexcept: st = {'state':'ACTIVE'}\n\ncur = st.get('state','ACTIVE')\nnew = cur\nif len(last20) >= 20 and fails >= 12: new = 'STAND_DOWN'\nif new == 'STAND_DOWN':\n  last3 = list(w)[-3:]\n  if len(last3) == 3 and all(x['fail']=='0' for x in last3): new = 'ACTIVE'\n\nif new != cur:\n  st['state'] = new\n  json.dump(st, open(STATE,'w'))\nPY"      },      "name": "Update State",      "type": "n8n-nodes-base.executeCommand",      "typeVersion": 1,      "position": [1880, 320]    }  ],  "connections": {    "Cron Hourly": { "main": [[{ "node": "Preflight Files", "type": "main", "index": 0 }]] },    "Preflight Files": { "main": [[{ "node": "Read Recent Events", "type": "main", "index": 0 }]] },    "Read Recent Events": { "main": [[{ "node": "Select Pending Signals", "type": "main", "index": 0 }]] },    "Select Pending Signals": { "main": [[{ "node": "Split Pending", "type": "main", "index": 0 }]] },    "Split Pending": { "main": [[{ "node": "Fetch OHLC 4H", "type": "main", "index": 0 }]] },    "Fetch OHLC 4H": { "main": [[{ "node": "Compute OUTCOME", "type": "main", "index": 0 }]] },    "Compute OUTCOME": { "main": [[{ "node": "Append OUTCOME event", "type": "main", "index": 0 }]] },    "Append OUTCOME event": { "main": [[{ "node": "Update State", "type": "main", "index": 0 }]] }  },  "active": false,  "settings": { "executionTimeout": 360, "saveExecutionProgress": true }}