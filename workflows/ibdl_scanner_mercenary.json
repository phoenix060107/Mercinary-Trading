{  "name": "ibdl_scanner_mercenary",  "nodes": [    {      "parameters": {        "triggerTimes": {          "item": [            {              "mode": "everyX",              "value": 1,              "unit": "hours"            }          ]        }      },      "name": "Cron Hourly",      "type": "n8n-nodes-base.cron",      "typeVersion": 1,      "position": [220, 300]    },    {      "parameters": {        "command": "set -e\nLOGDIR=\"/data/valkyrie/logs\"\nSTATE_FILE=\"$LOGDIR/ibdl_state.json\"\nEVENTS_FILE=\"$LOGDIR/mr_events.csv\"\n\nmkdir -p \"$LOGDIR\"\n\nif [ ! -f \"$STATE_FILE\" ]; then\n  echo '{\"state\":\"ACTIVE\",\"last_change_ts\":0}' > \"$STATE_FILE\"\nfi\n\nif [ ! -f \"$EVENTS_FILE\" ]; then\n  echo 'event_ts,event_type,signal_id,pair,entry_price,signal,mae_pct,mfe_pct,bars_to_ma50,hit_ma50,structure_hold,fail,state' > \"$EVENTS_FILE\"\nfi\n\necho \"OK\""      },      "name": "Preflight Files",      "type": "n8n-nodes-base.executeCommand",      "typeVersion": 1,      "position": [440, 300]    },    {      "parameters": {        "command": "cat /data/valkyrie/logs/ibdl_state.json"      },      "name": "Load State",      "type": "n8n-nodes-base.executeCommand",      "typeVersion": 1,      "position": [660, 300]    },    {      "parameters": {        "functionCode": "const raw = (items[0].json?.stdout || '').trim();\nlet state = { state: 'ACTIVE', last_change_ts: 0 };\ntry { state = JSON.parse(raw); } catch (e) {}\nreturn [{ json: { ibdl_state: state.state || 'ACTIVE' } }];"      },      "name": "Parse State",      "type": "n8n-nodes-base.function",      "typeVersion": 2,      "position": [880, 300]    },    {      "parameters": {        "url": "https://api.kraken.com/0/public/AssetPairs",        "options": {}      },      "name": "Get AssetPairs",      "type": "n8n-nodes-base.httpRequest",      "typeVersion": 4,      "position": [440, 500]    },    {      "parameters": {        "url": "https://api.kraken.com/0/public/Ticker",        "options": {}      },      "name": "Get Ticker (ALL)",      "type": "n8n-nodes-base.httpRequest",      "typeVersion": 4,      "position": [440, 640]    },    {      "parameters": {        "functionCode": "const MIN_USD_VOL = 5_000_000;\nconst TOP_N = 40;\n// FORCE THESE PAIRS TO BE SCANNED REGARDLESS OF VOLUME:\nconst WHITELIST = ['XMR/USD', 'SOL/USD', 'LTC/USD', 'XRP/USD', 'ETH/USD', 'BTC/USD'];\n\nconst pairs = items[0].json?.result || {};\nconst tickers = items[1].json?.result || {};\n\nconst out = [];\nfor (const [pairKey, p] of Object.entries(pairs)) {\n  const wsname = p.wsname || '';\n  if (!wsname.endsWith('/USD')) continue;\n  if (p.leverage_buy || p.leverage_sell) continue;\n\n  const t = tickers[pairKey] || tickers[p.altname] || null;\n  if (!t) continue;\n\n  const last = parseFloat((t.c && t.c[0]) || '0');\n  const baseVol24h = parseFloat((t.v && t.v[1]) || '0');\n  const approxQuoteVol = last * baseVol24h;\n\n  // Include if High Volume OR Whitelisted\n  const isWhitelisted = WHITELIST.includes(wsname);\n  \n  if (isWhitelisted || (Number.isFinite(approxQuoteVol) && approxQuoteVol >= MIN_USD_VOL)) {\n      out.push({\n        pairKey,\n        wsname,\n        last,\n        approxQuoteVol,\n        isWhitelisted\n      });\n  }\n}\n\n// Sort by volume, but ensure whitelist is kept\nout.sort((a,b) => b.approxQuoteVol - a.approxQuoteVol);\n\n// Take top N, but allow whitelist to exceed N if needed (or just ensure they are in the list)\n// Simple approach: Take top N, then add any missing whitelist items\nlet finalSet = out.slice(0, TOP_N);\nconst currentWsnames = new Set(finalSet.map(x => x.wsname));\n\nfor (const item of out) {\n    if (item.isWhitelisted && !currentWsnames.has(item.wsname)) {\n        finalSet.push(item);\n    }\n}\n\nreturn finalSet.map(x => ({ json: x }));"      },      "name": "Build USD Universe",      "type": "n8n-nodes-base.function",      "typeVersion": 2,      "position": [660, 580]    },    {      "parameters": {        "batchSize": 1,        "options": {}      },      "name": "Split Batches",      "type": "n8n-nodes-base.splitInBatches",      "typeVersion": 3,      "position": [880, 580]    },    {      "parameters": {        "amount": 1,        "unit": "seconds"      },      "name": "Wait 1s",      "type": "n8n-nodes-base.wait",      "typeVersion": 1,      "position": [1040, 580]    },    {      "parameters": {        "url": "https://api.kraken.com/0/public/OHLC",        "options": {},        "queryParametersUi": {          "parameter": [            { "name": "pair", "value": "={{$json.pairKey}}" },            { "name": "interval", "value": "240" }          ]        }      },      "name": "Get OHLC 4H",      "type": "n8n-nodes-base.httpRequest",      "typeVersion": 4,      "position": [1200, 580]    },    {      "parameters": {        "functionCode": "const LOOKBACK_BARS = 12;\nconst RSI_MIN = 35;\nconst RSI_MAX = 55; // Slightly stricter\nconst VOL_MULT = 1.10;\n\nfunction sma(arr, n) {\n  const out = new Array(arr.length).fill(null);\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (i >= n) sum -= arr[i - n];\n    if (i >= n - 1) out[i] = sum / n;\n  }\n  return out;\n}\n\nfunction rsi(closes, period=14) {\n  const out = new Array(closes.length).fill(null);\n  let gains = 0, losses = 0;\n  for (let i = 1; i <= period; i++) {\n    const d = closes[i] - closes[i - 1];\n    if (d >= 0) gains += d; else losses -= d;\n  }\n  let avgGain = gains / period;\n  let avgLoss = losses / period;\n  out[period] = avgLoss === 0 ? 100 : 100 - (100 / (1 + (avgGain / avgLoss)));\n\n  for (let i = period + 1; i < closes.length; i++) {\n    const d = closes[i] - closes[i - 1];\n    const gain = d > 0 ? d : 0;\n    const loss = d < 0 ? -d : 0;\n    avgGain = (avgGain * (period - 1) + gain) / period;\n    avgLoss = (avgLoss * (period - 1) + loss) / period;\n    out[i] = avgLoss === 0 ? 100 : 100 - (100 / (1 + (avgGain / avgLoss)));\n  }\n  return out;\n}\n\nconst pair = $json.wsname;\nconst pairKey = $json.pairKey;\nconst entryPrice = $json.last;\n\nconst resp = items[0].json;\nconst result = resp?.result || {};\nconst keys = Object.keys(result).filter(k => k !== 'last');\nif (!keys.length) return [{ json: { ok:false, pair, pairKey, signal_4h:false, reason:'No OHLC' } }];\n\nconst rows = result[keys[0]];\nif (!Array.isArray(rows) || rows.length < 210) {\n  return [{ json: { ok:false, pair, pairKey, signal_4h:false, reason:'Insufficient candles' } }];\n}\n\n// 4H Analysis\nconst recent = rows.slice(-220);\nconst closes = recent.map(r => parseFloat(r[4]));\nconst lows = recent.map(r => parseFloat(r[3]));\nconst vols = recent.map(r => parseFloat(r[6]));\n\nconst ma20 = sma(closes, 20);\nconst ma50 = sma(closes, 50);\nconst ma200 = sma(closes, 200);\nconst rsi14 = rsi(closes, 14);\nconst volSma20 = sma(vols, 20);\n\nconst i = closes.length - 1;\nconst prev = i - 1;\n\nconst lastClose = closes[i];\nconst lastMA20 = ma20[i];\nconst lastMA50 = ma50[i];\nconst lastMA200 = ma200[i];\nconst lastRSI = rsi14[i];\nconst prevRSI = rsi14[prev];\nconst lastVol = vols[i];\nconst lastVolAvg = volSma20[i];\n\n// 1. Strict Trend Permission\nconst trendPermission = (lastMA20 > lastMA50) && (lastClose > lastMA200);\n\n// 2. Pullback Check\nlet pullbackTouched = false;\nfor (let j = i - LOOKBACK_BARS; j <= i; j++) {\n  if (j < 0) continue;\n  if (lows[j] <= ma20[j] || lows[j] <= ma50[j]) { pullbackTouched = true; break; }\n}\n\n// 3. Reclaim & Volume\nconst rsiOk = (lastRSI >= RSI_MIN && lastRSI <= RSI_MAX) && (lastRSI > prevRSI);\nconst reclaim = (lastClose > lastMA20) && (recent[prev][4] <= ma20[prev] || recent[prev][3] <= ma20[prev]);\nconst volOk = lastVol >= (lastVolAvg * VOL_MULT);\n\nconst signal_4h = trendPermission && pullbackTouched && rsiOk && reclaim && volOk;\n\nreturn [{\n  json: {\n    ok: true,\n    pair,\n    pairKey,\n    entryPrice: lastClose,\n    signal_4h,\n    trendPermission,\n    lastRSI\n  }\n}];"      },      "name": "Compute 4H Signal",      "type": "n8n-nodes-base.function",      "typeVersion": 2,      "position": [1400, 580]    },    {      "parameters": {        "conditions": {          "boolean": [            {              "value1": "={{$json.signal_4h}}",              "value2": true            }          ]        }      },      "name": "IF 4H Valid",      "type": "n8n-nodes-base.if",      "typeVersion": 2,      "position": [1600, 580]    },    {      "parameters": {        "url": "https://api.kraken.com/0/public/OHLC",        "options": {},        "queryParametersUi": {          "parameter": [            { "name": "pair", "value": "={{$json.pairKey}}" },            { "name": "interval", "value": "15" }          ]        }      },      "name": "Get OHLC 15M",      "type": "n8n-nodes-base.httpRequest",      "typeVersion": 4,      "position": [1820, 560]    },    {      "parameters": {        "functionCode": "// 15M SNIPER VALIDATION\n// Prevents buying tops when 4H looks good but 15M is exhausted\n\nconst resp = items[0].json;\nconst result = resp?.result || {};\nconst keys = Object.keys(result).filter(k => k !== 'last');\n\nif (!keys.length) return [{ json: { ...$json, signal: false, reason: 'No 15M Data' } }];\n\nconst rows = result[keys[0]];\nconst recent = rows.slice(-50);\nconst closes = recent.map(r => parseFloat(r[4]));\n\nfunction rsi(closes, period=14) {\n  const out = new Array(closes.length).fill(null);\n  let gains = 0, losses = 0;\n  for (let i = 1; i <= period; i++) {\n    const d = closes[i] - closes[i - 1];\n    if (d >= 0) gains += d; else losses -= d;\n  }\n  let avgGain = gains / period;\n  let avgLoss = losses / period;\n  out[period] = avgLoss === 0 ? 100 : 100 - (100 / (1 + (avgGain / avgLoss)));\n\n  for (let i = period + 1; i < closes.length; i++) {\n    const d = closes[i] - closes[i - 1];\n    const gain = d > 0 ? d : 0;\n    const loss = d < 0 ? -d : 0;\n    avgGain = (avgGain * (period - 1) + gain) / period;\n    avgLoss = (avgLoss * (period - 1) + loss) / period;\n    out[i] = avgLoss === 0 ? 100 : 100 - (100 / (1 + (avgGain / avgLoss)));\n  }\n  return out;\n}\n\nconst rsi15 = rsi(closes, 14);\nconst currentRsi = rsi15[rsi15.length - 1];\n\n// LOGIC: \n// 1. If 15M RSI > 60, it's too hot (FOMO). Wait for pullback.\n// 2. If 15M RSI < 45, momentum might be dying.\n// 3. Sweet spot: 45 to 60\n\nconst rsiSafe = (currentRsi >= 45 && currentRsi <= 62);\n\nconst signal = rsiSafe;\nconst signalId = `${$json.pair.replace('/','_')}_${Math.floor(Date.now()/1000)}`;\n\nreturn [{\n    json: {\n        ...$json,\n        signal,\n        signalId,\n        rsi15: currentRsi,\n        reason: signal ? 'GO' : '15M RSI Too Hot/Cold'\n    }\n}];"      },      "name": "Validate 15M",      "type": "n8n-nodes-base.function",      "typeVersion": 2,      "position": [2020, 560]    },    {      "parameters": {        "functionCode": "const state = $items('Parse State')[0].json.ibdl_state;\nitems[0].json.state = state;\nreturn items;"      },      "name": "Attach State",      "type": "n8n-nodes-base.function",      "typeVersion": 2,      "position": [2220, 560]    },    {      "parameters": {        "command": "set -e\nLOG='/data/valkyrie/logs/mr_events.csv'\n\nEVENT_TS=$(date +%s)\nEVENT_TYPE='SIGNAL'\nSIGNAL_ID='{{$json.signalId}}'\nPAIR='{{$json.pair}}'\nENTRY_PRICE='{{$json.entryPrice}}'\nSIGNAL='{{$json.signal}}'\nSTATE='{{$json.state}}'\n\n# Outcome fields blank for SIGNAL events\nMAE=''\nMFE=''\nBARS=''\nHIT=''\nSTRUCT=''\nFAIL=''\n\necho \"$EVENT_TS,$EVENT_TYPE,$SIGNAL_ID,$PAIR,$ENTRY_PRICE,$SIGNAL,$MAE,$MFE,$BARS,$HIT,$STRUCT,$FAIL,$STATE\" >> \"$LOG\"\n\necho \"OK\""      },      "name": "Append SIGNAL event",      "type": "n8n-nodes-base.executeCommand",      "typeVersion": 1,      "position": [2420, 560]    },    {      "parameters": {        "conditions": {          "boolean": [            { "value1": "={{$json.state}}", "value2": "ACTIVE" },            { "value1": "={{$json.signal}}", "value2": true }          ]        }      },      "name": "IF ACTIVE & SIGNAL",      "type": "n8n-nodes-base.if",      "typeVersion": 2,      "position": [2620, 560]    },    {      "parameters": {        "url": "={{$env.DISCORD_WEBHOOK_URL}}",        "options": {},        "method": "POST",        "sendBody": true,        "specifyBody": "json",        "jsonBody": "={\"content\":\"ðŸš€ VALKYRIE SIGNAL (Confirmed)\\nPair: {{$json.pair}}\\nPrice: {{$json.entryPrice}}\\n4H Trend: UP\\n15M RSI: {{$json.rsi15}}\\nSignalId: {{$json.signalId}}\"}"      },      "name": "Discord Alert",      "type": "n8n-nodes-base.httpRequest",      "typeVersion": 4,      "position": [2840, 500]    },    {      "parameters": {},      "name": "No-op End",      "type": "n8n-nodes-base.noOp",      "typeVersion": 1,      "position": [2840, 700]    }  ],  "connections": {    "Cron Hourly": { "main": [[{ "node": "Preflight Files", "type": "main", "index": 0 }]] },    "Preflight Files": { "main": [[{ "node": "Load State", "type": "main", "index": 0 }]] },    "Load State": { "main": [[{ "node": "Parse State", "type": "main", "index": 0 }]] },    "Parse State": { "main": [[{ "node": "Get AssetPairs", "type": "main", "index": 0 }, { "node": "Get Ticker (ALL)", "type": "main", "index": 0 }]] },    "Get AssetPairs": { "main": [[{ "node": "Build USD Universe", "type": "main", "index": 0 }]] },    "Get Ticker (ALL)": { "main": [[{ "node": "Build USD Universe", "type": "main", "index": 1 }]] },    "Build USD Universe": { "main": [[{ "node": "Split Batches", "type": "main", "index": 0 }]] },    "Split Batches": { "main": [[{ "node": "Wait 1s", "type": "main", "index": 0 }]] },    "Wait 1s": { "main": [[{ "node": "Get OHLC 4H", "type": "main", "index": 0 }]] },    "Get OHLC 4H": { "main": [[{ "node": "Compute 4H Signal", "type": "main", "index": 0 }]] },    "Compute 4H Signal": { "main": [[{ "node": "IF 4H Valid", "type": "main", "index": 0 }]] },    "IF 4H Valid": {      "main": [          [{ "node": "Get OHLC 15M", "type": "main", "index": 0 }],          [{ "node": "Split Batches", "type": "main", "index": 0 }]      ]    },    "Get OHLC 15M": { "main": [[{ "node": "Validate 15M", "type": "main", "index": 0 }]] },    "Validate 15M": { "main": [[{ "node": "Attach State", "type": "main", "index": 0 }]] },    "Attach State": { "main": [[{ "node": "Append SIGNAL event", "type": "main", "index": 0 }]] },    "Append SIGNAL event": { "main": [[{ "node": "IF ACTIVE & SIGNAL", "type": "main", "index": 0 }]] },    "IF ACTIVE & SIGNAL": {      "main": [        [{ "node": "Discord Alert", "type": "main", "index": 0 }],        [{ "node": "No-op End", "type": "main", "index": 0 }]      ]    },    "Discord Alert": { "main": [[{ "node": "No-op End", "type": "main", "index": 0 }]] }  },  "active": false,  "settings": { "executionTimeout": 360, "saveExecutionProgress": true }}